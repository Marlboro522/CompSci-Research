@INPROCEEDINGS{1003559,
  author={Sprangle, E. and Carmean, D.},
  booktitle={Proceedings 29th Annual International Symposium on Computer Architecture}, 
  title={Increasing processor performance by implementing deeper pipelines}, 
  year={2002},
  volume={},
  number={},
  pages={25-34},
  keywords={Pipelines;Frequency;Delay;Analytical models;Degradation;System-on-a-chip;Process design;Microprocessors;Predictive models;Computer architecture},
  doi={10.1109/ISCA.2002.1003559}}


@misc{SurveyTechniquesDynamica,
	title = {A {Survey} of {Techniques} for {Dynamic} {Branch} {Prediction}},
	url = {https://ar5iv.labs.arxiv.org/html/1804.00261},
	abstract = {Branch predictor (BP) is an essential component in modern processors since high BP accuracy can improve performance and reduce energy by decreasing the number of instructions executed on wrong-path. However, reducing l…},
	language = {en},
	urldate = {2024-10-18},
	journal = {ar5iv},
	file = {Snapshot:/Users/ilu/Zotero/storage/FLJXG3WV/1804.html:text/html},
}

@misc{penneySurveyMachineLearning2019a,
	title = {A {Survey} of {Machine} {Learning} {Applied} to {Computer} {Architecture} {Design}},
	url = {http://arxiv.org/abs/1909.12373},
	doi = {10.48550/arXiv.1909.12373},
	abstract = {Machine learning has enabled significant benefits in diverse fields, but, with a few exceptions, has had limited impact on computer architecture. Recent work, however, has explored broader applicability for design, optimization, and simulation. Notably, machine learning based strategies often surpass prior state-of-the-art analytical, heuristic, and human-expert approaches. This paper reviews machine learning applied system-wide to simulation and run-time optimization, and in many individual components, including memory systems, branch predictors, networks-on-chip, and GPUs. The paper further analyzes current practice to highlight useful design strategies and identify areas for future work, based on optimized implementation strategies, opportune extensions to existing work, and ambitious long term possibilities. Taken together, these strategies and techniques present a promising future for increasingly automated architectural design.},
	urldate = {2024-10-18},
	publisher = {arXiv},
	author = {Penney, Drew D. and Chen, Lizhong},
	month = sep,
	year = {2019},
	note = {arXiv:1909.12373},
	keywords = {Computer Science - Artificial Intelligence, Computer Science - Hardware Architecture, Computer Science - Machine Learning},
	file = {Preprint PDF:/Users/ilu/Zotero/storage/TMN7FKNQ/Penney and Chen - 2019 - A Survey of Machine Learning Applied to Computer Architecture Design.pdf:application/pdf;Snapshot:/Users/ilu/Zotero/storage/IFV7WNPC/1909.html:text/html},
}

@misc{josephSurveyDeepLearning2021a,
	title = {A {Survey} of {Deep} {Learning} {Techniques} for {Dynamic} {Branch} {Prediction}},
	url = {http://arxiv.org/abs/2112.14911},
	doi = {10.48550/arXiv.2112.14911},
	abstract = {Branch prediction is an architectural feature that speeds up the execution of branch instruction on pipeline processors and reduces the cost of branching. Recent advancements of Deep Learning (DL) in the post Moore's Law era is accelerating areas of automated chip design, low-power computer architectures, and much more. Traditional computer architecture design and algorithms could benefit from dynamic predictors based on deep learning algorithms which learns from experience by optimizing its parameters on large number of data. In this survey paper, we focus on traditional branch prediction algorithms, analyzes its limitations, and presents a literature survey of how deep learning techniques can be applied to create dynamic branch predictors capable of predicting conditional branch instructions. Prior surveys in this field focus on dynamic branch prediction techniques based on neural network perceptrons. We plan to improve the survey based on latest research in DL and advanced Machine Learning (ML) based branch predictors.},
	urldate = {2024-10-18},
	publisher = {arXiv},
	author = {Joseph, Rinu},
	month = dec,
	year = {2021},
	note = {arXiv:2112.14911},
	keywords = {Computer Science - Artificial Intelligence, Computer Science - Hardware Architecture, Computer Science - Machine Learning},
	file = {Preprint PDF:/Users/ilu/Zotero/storage/2EVZ7YTL/Joseph - 2021 - A Survey of Deep Learning Techniques for Dynamic Branch Prediction.pdf:application/pdf;Snapshot:/Users/ilu/Zotero/storage/K49CUWUW/2112.html:text/html},
}

@misc{DocumentationPageNot,
	title = {Documentation page not found - {Read} the {Docs}},
	url = {https://marss-riscv-docs.readthedocs.io/en/latest/sections/branch-pred},
	urldate = {2024-10-18},
}

@misc{BranchPredictionUnita,
	title = {3. {Branch} {Prediction} {Unit} — {MARSS}-{RISCV} 4.1a documentation},
	url = {https://marss-riscv-docs.readthedocs.io/en/latest/sections/branch-pred.html},
	urldate = {2024-10-18},
}

@inproceedings{heSurveyComparisonPipeline2023a,
	title = {Survey and {Comparison} of {Pipeline} of {Some} {RISC} and {CISC} {System} {Architectures}},
	url = {https://ieeexplore.ieee.org/document/10150975},
	doi = {10.1109/ICCCS57501.2023.10150975},
	abstract = {Instruction set is a set of instructions used by CPU to calculate and control computer system, and is the interface between hardware and software. There are two common instruction sets: CISC and RISC. Pipeline technology is widely used in instruction set processor design to improve the efficiency of executing instructions. This paper introduces the difference between CISC and RISC in pipeline implementation, introduces the basic pipelining and two advanced pipelining - superscalar and superpipelining in detail, and introduces several pipelining using CISC and RISC architecture processors, including ARM, RISC-V, Longarch, and X86.},
	urldate = {2024-10-18},
	booktitle = {2023 8th {International} {Conference} on {Computer} and {Communication} {Systems} ({ICCCS})},
	author = {He, Yan and Chen, Xiangning},
	month = apr,
	year = {2023},
	keywords = {CISC, Communication systems, Computer architecture, Control systems, Pipeline, processor, Reduced instruction set computing, RISC, Software, superpipelining, superscalar, Surveys, Systems architecture},
	pages = {785--790},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/6I5BF37U/He and Chen - 2023 - Survey and Comparison of Pipeline of Some RISC and CISC System Architectures.pdf:application/pdf},
}

@article{emmaCharacterizationBranchData1987a,
	title = {Characterization of {Branch} and {Data} {Dependencies} in {Programs} for {Evaluating} {Pipeline} {Performance}},
	volume = {C-36},
	issn = {1557-9956},
	url = {https://ieeexplore.ieee.org/document/1676981},
	doi = {10.1109/TC.1987.1676981},
	abstract = {The nature by which branches and data dependencies generate delays that degrade pipeline performance is investigated in this paper. We show that for the general execution trace, few specific delays can be considered in isolation; rather, the magnitude of any specific delay may depend on the relative proximity of other delays. This phenomenon can make the task of accurately characterizing a trace tape with simple statistics intractable. We present a set of trace reductions that facilitates this task by simplifying the corresponding data-dependency graph. The reductions operate on multiple data-dependency arcs and branches in conjunction; those arcs whose performance implications are redundant with respect to the dependency graph are identified, and eliminated from the graph. We show that the reduced graph can be accurately characterized by simple statistics. We use these statistics to show that as the length of a pipeline increases, the performance degradation due to data dependencies and branches increases monotonically. However, lengthening the pipeline may correspond to decreasing the cycle time of the pipeline. These two opposing effects are used in conjunction to derive an equation for optimal pipeline length for a given trace tape. The optimal pipeline length is shown to be characterized by n = √γα where γ is the ratio of overall circuit delay to latching overhead, and a is a function of the trace statistics that accounts for the delays induced by data dependencies and branches.},
	number = {7},
	urldate = {2024-10-18},
	journal = {IEEE Transactions on Computers},
	author = {{Emma} and {Davidson}},
	month = jul,
	year = {1987},
	note = {Conference Name: IEEE Transactions on Computers},
	keywords = {Branch delay, data dependency, performance analysis, pipeline, program trace, trace reduction},
	pages = {859--875},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/S5E34F8H/Emma and Davidson - 1987 - Characterization of Branch and Data Dependencies in Programs for Evaluating Pipeline Performance.pdf:application/pdf},
}

@inproceedings{hoogerbruggeDynamicBranchPrediction2000a,
	title = {Dynamic branch prediction for a {VLIW} processor},
	url = {https://ieeexplore.ieee.org/abstract/document/888345},
	doi = {10.1109/PACT.2000.888345},
	abstract = {This paper describes the design of a dynamic branch predictor for a VLIW processor. The developed branch predictor predicts the direction of a branch, i.e., taken or not taken, and in the case of taken prediction it also predicts the issue-slot that contains the taken branch. This information is used to perform the BTB lookup. We compare this method against a typical superscalar branch predictor and against a branch predictor developed for VLIWs by Intel and HP. For a 2K entry BHT, 512 entry BTB, gshare branch predictor we obtain a next pc misprediction rate of 7.83\%, while a traditional superscalar-type branch predictor of comparable costs achieves 10.3\% and the Intel/HP predictor achieves 9.31\%. In addition, we propose to have both predicted and delayed branches in the ISA and let the compiler select which type to apply. Simulations show performance improvements of 2-7\% for benchmarks that are well-known for their high misprediction rates. This paper also contributes an experiment to determine whether speculative update in the fetch stage and correction of mispredictions is really necessary for VLIWs, instead of updating when branches are resolved. Experiments show that the performance advantage of speculative updating is small.},
	urldate = {2024-10-18},
	booktitle = {Proceedings 2000 {International} {Conference} on {Parallel} {Architectures} and {Compilation} {Techniques} ({Cat}. {No}.{PR00622})},
	author = {Hoogerbrugge, J.},
	month = oct,
	year = {2000},
	note = {ISSN: 1089-795X},
	keywords = {Accuracy, Costs, Delay effects, Dynamic scheduling, Filling, History, Instruction sets, Laboratories, Processor scheduling, VLIW},
	pages = {207--214},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/DGXNGBVS/Hoogerbrugge - 2000 - Dynamic branch prediction for a VLIW processor.pdf:application/pdf},
}

@article{eversUsingHybridBranch1996a,
	title = {Using hybrid branch predictors to improve branch prediction accuracy in the presence of context switches},
	volume = {24},
	issn = {0163-5964},
	url = {https://dl.acm.org/doi/10.1145/232974.232975},
	doi = {10.1145/232974.232975},
	abstract = {Pipeline stalls due to conditional branches represent one of the most significant impediments to realizing the performance potential of deeply pipelined, superscalar processors. Many branch predictors have been proposed to help alleviate this problem, including the Two-Level Adaptive Branch Predictor, and more recently, two-component hybrid branch predictors.In a less idealized environment, such as a time-shared system, code of interest involves context switches. Context switches, even at fairly large intervals, can seriously degrade the performance of many of the most accurate branch prediction schemes. In this paper, we introduce a new hybrid branch predictor and show that it is more accurate (for a given cost) than any previously published scheme, especially if the branch histories are periodically flushed due to the presence of context switches.},
	number = {2},
	urldate = {2024-10-18},
	journal = {SIGARCH Comput. Archit. News},
	author = {Evers, Marius and Chang, Po-Yung and Patt, Yale N.},
	month = may,
	year = {1996},
	pages = {3--11},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/P63HKTG3/Evers et al. - 1996 - Using hybrid branch predictors to improve branch prediction accuracy in the presence of context swit.pdf:application/pdf},
}

@inproceedings{calderFastAccurateInstruction1994a,
	address = {Washington, DC, USA},
	series = {{ISCA} '94},
	title = {Fast and accurate instruction fetch and branch prediction},
	isbn = {978-0-8186-5510-4},
	url = {https://dl.acm.org/doi/10.1145/191995.192011},
	doi = {10.1145/191995.192011},
	abstract = {Accurate branch prediction is critical to performance; mispredicted branches mean that ten's of cycles may be wasted in superscalar architectures. Architectures combining very effective branch prediction mechanisms coupled with modified branch target buffers (BTB's) have been proposed for wide-issue processors. These mechanisms require considerable processor resources. Concurrently, the larger address space of 64-bit architectures introduce new obstacles and opportunities. A larger address space means branch target buffers become more expensive. In this paper, we show how a combination of less expensive mechanisms can achieve better performance than BTB's. This combination relies on a number of design choices described in the paper. We used trace-driven simulation to show that our proposed design, which uses fewer resources, offers better performance than previously proposed alternatives for most programs, and indicate how to further improve this design.},
	urldate = {2024-10-17},
	booktitle = {Proceedings of the 21st annual international symposium on {Computer} architecture},
	publisher = {IEEE Computer Society Press},
	author = {Calder, B. and Grunwald, D.},
	month = apr,
	year = {1994},
	pages = {2--11},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/6WBAIXRM/Calder and Grunwald - 1994 - Fast and accurate instruction fetch and branch prediction.pdf:application/pdf},
}

@misc{linBranchPredictionNot2019a,
	title = {Branch {Prediction} {Is} {Not} a {Solved} {Problem}: {Measurements}, {Opportunities}, and {Future} {Directions}},
	shorttitle = {Branch {Prediction} {Is} {Not} a {Solved} {Problem}},
	url = {http://arxiv.org/abs/1906.08170},
	doi = {10.48550/arXiv.1906.08170},
	abstract = {Modern branch predictors predict the vast majority of conditional branch instructions with near-perfect accuracy, allowing superscalar, out-of-order processors to maximize speculative efficiency and thus performance. However, this impressive overall effectiveness belies a substantial missed opportunity in single-threaded instructions per cycle (IPC). For example, we show that correcting the mispredictions made by the state-of-the-art TAGE-SC-L branch predictor on SPECint 2017 would improve IPC by margins similar to an advance in process technology node. In this work, we measure and characterize these mispredictions. We find that they categorically arise from either (1) a small number of systematically hard-to-predict (H2P) branches; or (2) rare branches with low dynamic execution counts. Using data from SPECint 2017 and additional large code footprint applications, we quantify the occurrence and IPC impact of these two categories. We then demonstrate that increasing the resources afforded to existing branch predictors does not alone address the root causes of most mispredictions. This leads us to reexamine basic assumptions in branch prediction and to propose new research directions that, for example, deploy machine learning to improve pattern matching for H2Ps, and use on-chip phase learning to track long-term statistics for rare branches.},
	urldate = {2024-10-18},
	publisher = {arXiv},
	author = {Lin, Chit-Kwan and Tarsa, Stephen J.},
	month = jun,
	year = {2019},
	note = {arXiv:1906.08170 
version: 1},
	keywords = {Computer Science - Distributed, Parallel, and Cluster Computing, Computer Science - Hardware Architecture},
	file = {Preprint PDF:/Users/ilu/Zotero/storage/HWHSYS9D/Lin and Tarsa - 2019 - Branch Prediction Is Not a Solved Problem Measurements, Opportunities, and Future Directions.pdf:application/pdf;Snapshot:/Users/ilu/Zotero/storage/ESNZWAFS/1906.html:text/html},
}

@article{mohammadiDemandDynamicBranch2015a,
	title = {On-{Demand} {Dynamic} {Branch} {Prediction}},
	volume = {14},
	issn = {1556-6064},
	url = {https://ieeexplore.ieee.org/abstract/document/6834760?casa_token=lHuqEKUMvOkAAAAA},
	doi = {10.1109/LCA.2014.2330820},
	abstract = {In out-of-order (OoO) processors, speculative execution with high branch prediction accuracy is employed to achieve good single thread performance. In these processors the branch prediction unit tables (BPU) are accessed in parallel with the instruction cache before it is known whether a fetch group contains branch instructions. For integer applications, we find 85 percent of BPU lookups are done for non-branch operations and of the remaining lookups, 42 percent are done for highly biased branches that can be predicted statically with high accuracy. We evaluate on-demand branch prediction (ODBP), a novel technique that uses compiler generated hints to identify those instructions that can be more accurately predicted statically to eliminate unnecessary BPU lookups. We evaluate an implementation of ODBP that combines static and dynamic branch prediction. For a four wide superscalar processor, ODBP delivers as much as 9 percent improvement in average energy-delay (ED) product, 7 percent core average energy saving, and 3 percent speedup. ODBP also enables the use of large BPU’s for a given power budget.},
	number = {1},
	urldate = {2024-10-18},
	journal = {IEEE Computer Architecture Letters},
	author = {Mohammadi, Milad and Han, Song and Aamodt, Tor M. and Dally, William J.},
	month = jan,
	year = {2015},
	note = {Conference Name: IEEE Computer Architecture Letters},
	keywords = {Accuracy, ahead prediction, Computer architecture, Energy efficiency, energy-delay product optimization, Equations, Mathematical model, Pipelines, Program processors, static and dynamic branch prediction hybrid, Tin},
	pages = {50--53},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/Z52C3GN8/Mohammadi et al. - 2015 - On-Demand Dynamic Branch Prediction.pdf:application/pdf},
}

@article{uhtDisjointEagerExecution2002,
	title = {Disjoint {Eager} {Execution}: what it is / what it is not},
	volume = {30},
	issn = {0163-5964},
	shorttitle = {Disjoint {Eager} {Execution}},
	url = {https://dl.acm.org/doi/10.1145/511120.511124},
	doi = {10.1145/511120.511124},
	abstract = {Disjoint Eager Execution (DEE) has been cited and described many times since its introduction in 1992, often incorrectly. This paper clarifies what DEE is and how it operates, as well as pointing out common DEE misconceptions.},
	number = {1},
	urldate = {2024-10-18},
	journal = {SIGARCH Comput. Archit. News},
	author = {Uht, Augustus K.},
	month = mar,
	year = {2002},
	pages = {12--14},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/K5ZTGMJ7/Uht - 2002 - Disjoint Eager Execution what it is  what it is not.pdf:application/pdf},
}

@inproceedings{grunwaldStaticMethodsHybrid1998,
	title = {Static methods in hybrid branch prediction},
	url = {https://ieeexplore.ieee.org/abstract/document/727254},
	doi = {10.1109/PACT.1998.727254},
	abstract = {Hybrid branch predictors combine the predictions of multiple single-level or two-level branch predictors. The prediction-combining hardware-the "meta-predictor"-may itself be large, complex and slow. We show that the combination function is better performed statically, using prediction hints in the branch instructions. The hints are set by profiling or static analysis. Although the meta-predictor is static, the actual predictions remain dynamic, so there is little risk of worst-case performance. An important advantage of our approach is that a branch site only causes interference within a single component predictor reducing capacity demands. We argue that our proposal is implementable, and that it addresses the scaling issues currently facing hardware designers. We show that the static hybrid method we propose is more effective than existing techniques based on dynamic selection, and requires less hardware. For example, one result shows a conventional 4096-bit dynamic selection mechanism getting a 4.7\% average miss rate, while our static approach gets 3.6\%. These results are obtained with the Instruction Benchmark Suite (IBS), a realistic whole-system benchmark, and the SPECint95 suite, using realistic hardware sizes. All the results we present are based on a cross-validation methodology, in which the profile data used for static selection are based on training inputs that are entirely different from the inputs used to evaluate the performance of the technique.},
	urldate = {2024-10-18},
	booktitle = {Proceedings. 1998 {International} {Conference} on {Parallel} {Architectures} and {Compilation} {Techniques} ({Cat}. {No}.{98EX192})},
	author = {Grunwald, D. and Lindsay, D. and Zorn, B.},
	month = oct,
	year = {1998},
	note = {ISSN: 1089-795X},
	keywords = {Checkpointing, Computer science, Costs, Electronic switching systems, Hardware, Impedance, Pipelines, Proposals, Read only memory},
	pages = {222--229},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/G3326ZM4/Grunwald et al. - 1998 - Static methods in hybrid branch prediction.pdf:application/pdf},
}

@article{nainImplementationComparisonBimodal2021,
	title = {Implementation and comparison of bi-modal dynamic branch prediction with static branch prediction schemes},
	volume = {13},
	issn = {2511-2112},
	url = {https://doi.org/10.1007/s41870-021-00631-z},
	doi = {10.1007/s41870-021-00631-z},
	abstract = {In a parallel processor, the pipeline cannot fetch the conditional instructions with the next clock cycle, leading to a pipeline stall. So, conditional instructions create a problem in the pipeline because the proper path can only be known after the branch execution. To accurately predict branches, a significant predictor is proposed for the prediction of the conditional branch instruction. Firstly, the always taken prediction scheme and always not-taken prediction scheme are applied to the trace files using a static branch prediction scheme. Further, a bi-modal dynamic branch prediction scheme is proposed, which uses the saturating counter to provide more accuracy rate than the other prediction schemes. The result suggests that the proposed bi-modal dynamic branch prediction scheme provides a higher accuracy rate than always taken and always not-taken static branch prediction by the rate of 9.82\% and 6.12\%, respectively. Moreover, the proposed bi-modal dynamic branch prediction limits the misprediction rate by 10.33\% and 8.16\% compared with the always taken and always not-taken static branch prediction scheme.},
	language = {en},
	number = {3},
	urldate = {2024-10-18},
	journal = {Int. j. inf. tecnol.},
	author = {Nain, Sweety and Chaudhary, Prachi},
	month = jun,
	year = {2021},
	keywords = {Accuracy rate, Artificial Intelligence, Dynamic branch prediction, Mis-prediction rate, Static branch prediction, The pipeline processor},
	pages = {1145--1153},
}

@inproceedings{yehTwolevelAdaptiveTraining1991,
	address = {New York, NY, USA},
	series = {{MICRO} 24},
	title = {Two-level adaptive training branch prediction},
	isbn = {978-0-89791-460-4},
	url = {https://dl.acm.org/doi/10.1145/123465.123475},
	doi = {10.1145/123465.123475},
	urldate = {2024-10-17},
	booktitle = {Proceedings of the 24th annual international symposium on {Microarchitecture}},
	publisher = {Association for Computing Machinery},
	author = {Yeh, Tse-Yu and Patt, Yale N.},
	month = sep,
	year = {1991},
	pages = {51--61},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/VQM6BP9I/Yeh and Patt - 1991 - Two-level adaptive training branch prediction.pdf:application/pdf},
}

@article{yehAlternativeImplementationsTwolevel1992,
	title = {Alternative implementations of two-level adaptive branch prediction},
	volume = {20},
	issn = {0163-5964},
	url = {https://dl.acm.org/doi/10.1145/146628.139709},
	doi = {10.1145/146628.139709},
	abstract = {As the issue rate and depth of pipelining of high performance Superscalar processors increase, the importance of an excellent branch predictor becomes more vital to delivering the potential performance of a wide-issue, deep pipelined microarchitecture. We propose a new dynamic branch predictor (Two-Level Adaptive Branch Prediction) that achieves substantially higher accuracy than any other scheme reported in the literature. The mechanism uses two levels of branch history information to make predictions, the history of the last k branches encountered, and the branch behavior for the last s occurrences of the specific pattern of these k branches. We have identified three variations of the Two-Level Adaptive Branch Prediction, depending  on how finely we resolve the history information gathered. We compute the hardware costs of implementing each of the three variations, and use these costs in evaluating their relative effectiveness. We measure the branch prediction accuracy of the three variations of two-Level Adaptive Branch Prediction, along with several other popular proposed dynamic and static prediction schemes, on the SPEC benchmarks. We show that the average prediction accuracy for Two-Level Adaptive Branch Prediction is 97 percent, while the other known schemes achieve at most 94.4 percent average prediction accuracy. We measure the effectiveness of different prediction algorithms and different amounts of history and pattern information. We measure the costs of each variation to obtain the same prediction   accuracy.},
	number = {2},
	urldate = {2024-10-18},
	journal = {SIGARCH Comput. Archit. News},
	author = {Yeh, Tse-Yu and Patt, Yale N.},
	month = apr,
	year = {1992},
	pages = {124--134},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/IGR3FHR9/Yeh and Patt - 1992 - Alternative implementations of two-level adaptive branch prediction.pdf:application/pdf},
}

@article{eganTwolevelBranchPrediction2003,
	series = {Synthesis and {Verification}},
	title = {Two-level branch prediction using neural networks},
	volume = {49},
	issn = {1383-7621},
	url = {https://www.sciencedirect.com/science/article/pii/S138376210300095X},
	doi = {10.1016/S1383-7621(03)00095-X},
	abstract = {Dynamic branch prediction in high-performance processors is a specific instance of a general time series prediction problem that occurs in many areas of science. Most branch prediction research focuses on two-level adaptive branch prediction techniques, a very specific solution to the branch prediction problem. An alternative approach is to look to other application areas and fields for novel solutions to the problem. In this paper, we examine the application of neural networks to dynamic branch prediction. We retain the first level history register of conventional two-level predictors and replace the second level PHT with a neural network. Two neural networks are considered: a learning vector quantisation network and a backpropagation network. We demonstrate that a neural predictor can achieve misprediction rates comparable to conventional two-level adaptive predictors and suggest that neural predictors merit further investigation.},
	number = {12},
	urldate = {2024-10-18},
	journal = {Journal of Systems Architecture},
	author = {Egan, Colin and Steven, Gordon and Quick, Patrick and Anguera, Rubén and Steven, Fleur and Vintan, Lucian},
	month = dec,
	year = {2003},
	keywords = {Backpropagation network, Learning vector quantisation network, Neural branch prediction, Two-level adaptive branch prediction},
	pages = {557--570},
}

@inproceedings{yehComparisonDynamicBranch1993,
	address = {New York, NY, USA},
	series = {{ISCA} '93},
	title = {A comparison of dynamic branch predictors that use two levels of branch history},
	isbn = {978-0-8186-3810-7},
	url = {https://dl.acm.org/doi/10.1145/165123.165161},
	doi = {10.1145/165123.165161},
	abstract = {Recent attention to speculative execution as a mechanism for increasing performance of single instruction streams has demanded substantially better branch prediction than what has been previously available. We [1,2] and Pan, So, and Rahmen [4] have both proposed variations of the same aggressive dynamic branch predictor for handling those needs. We call the basic model Two-Level Adaptive Branch Prediction; Pan, So, and Rahmeh call it Correlation Branch Prediction. In this paper, we adopt the terminology of [2] and show that there are really nine variations of the same basic model. We compare the nine variations with respect to the amount of history information kept. We study the effects of different branch history lengths and pattern history table configurations. Finally, we evaluate  the cost effectiveness of the nine variations.},
	urldate = {2024-10-17},
	booktitle = {Proceedings of the 20th annual international symposium on computer architecture},
	publisher = {Association for Computing Machinery},
	author = {Yeh, Tse-Yu and Patt, Yale N.},
	month = may,
	year = {1993},
	pages = {257--266},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/YRQVKXJC/Yeh and Patt - 1993 - A comparison of dynamic branch predictors that use two levels of branch history.pdf:application/pdf},
}

@misc{EfficientIntegrationBimodal,
	title = {Efficient integration of bimodal branch prediction and pipeline analysis {\textbar} {IEEE} {Conference} {Publication} {\textbar} {IEEE} {Xplore}},
	url = {https://ieeexplore.ieee.org/abstract/document/1541054},
	urldate = {2024-10-18},
}

@inproceedings{choudhuryOptimizedRISCVProcessor2022,
	title = {An optimized {RISC}-{V} processor with five stage pipelining using {Tournament} {Branch} {Predictor} for efficient performance},
	url = {https://ieeexplore.ieee.org/abstract/document/9974891},
	doi = {10.1109/DISCOVER55800.2022.9974891},
	abstract = {A RISC-V is an open-source standard computer architecture that uses reduced instruction sets and provides researchers and developers to learn, develop and contribute to the existing architecture. The computer organization covers a huge range of scope for development. One such scope, is the branching technique in an architecture that contributes to the speed and accuracy of the execution and hence leading to one of the important factors for improving the efficiency of the processor. The methodology and design to implement such different branching techniques and the importance of branch predictors has been a major part of the research. The design of a micro-architecture and implementation on the existing processor has brought up the scope of analyzing and comparing these techniques. A tournament branch predictor has been designed and implemented using previously used branching techniques to increase the processor speed and achieve better accuracy. The comparative analysis of a tournament branch predictor shows greater number of instructions is executed in a tournament branch predictor. Instruction per second (IPS) rate for a branch comparator is 3.93 x 10{\textasciicircum}9 whereas for a tournament branch predictor architecture, the rate is 2.18 x 1010 which executes 10 times more instructions per second.},
	urldate = {2024-10-18},
	booktitle = {2022 {International} {Conference} on {Distributed} {Computing}, {VLSI}, {Electrical} {Circuits} and {Robotics} ( {DISCOVER})},
	author = {Choudhury, Ananya and Siddamal, Saroja V and Mallidue, Jayashree},
	month = oct,
	year = {2022},
	keywords = {Computer architecture, computer organization, Instruction sets, Instructions per second, IP networks, micro architecture, Microarchitecture, Organizations, pipelined processor, Standards organizations, Tournament branch predictor, Very large scale integration},
	pages = {57--60},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/RVDNGJQW/Choudhury et al. - 2022 - An optimized RISC-V processor with five stage pipelining using Tournament Branch Predictor for effic.pdf:application/pdf},
}

@inproceedings{seznecNewCaseTAGE2011,
	address = {New York, NY, USA},
	series = {{MICRO}-44},
	title = {A new case for the {TAGE} branch predictor},
	isbn = {978-1-4503-1053-6},
	url = {https://dl.acm.org/doi/10.1145/2155620.2155635},
	doi = {10.1145/2155620.2155635},
	abstract = {The TAGE predictor is often considered as state-of-the-art in conditional branch predictors proposed by academy. In this paper, we first present directions to reduce the hardware implementation cost of TAGE. Second we show how to further reduce the misprediction rate of TAGE through augmenting it with small side predictors.On a hardware implementation of a conditional branch predictor, the predictor tables are updated at retire time. A retired branch normally induces three accesses to the branch predictor tables: read at prediction time, read at retire time and write for the update. We show that in practice, the TAGE predictor accuracy would not be significantly impaired by avoiding a systematic second read of the prediction tables at retire time for correct prediction. Combined with the elimination of silent updates, this significantly reduces the number of accesses to the predictor. Furthermore, we present a technique allowing to implement the TAGE predictor tables as bank-interleaved structures using single-port memory components. This significantly reduces the silicon footprint of the predictor as well as its energy consumption without significantly impairing its accuracy.In the last few years, progress in branch prediction accuracy has relied on associating a main state-of-the-art single scheme branch predictor with specialized side predictors. As a second contribution of the paper, we develop this side predictor approach for TAGE. At the recent 3rd Championship Branch Prediction, it was shown that the TAGE predictor can be augmented with several side predictors, each one addressing a category of predictions that is not optimally addressed by TAGE. The Immediate Update Mimicker tracks the inflight already executed but not retired branches and use their result for correcting the predictions. Sometimes TAGE fails to predict when the control flow path inside the loop body is irregular. TAGE can be augmented with a loop predictor to predict loops with constant iteration numbers, TAGE also sometimes fails to predict branches that are not strongly biased but that are only statistically biased. The Statistical Corrector Predictor is introduced to track these statistically correlated branches. These side predictors allow to increase the prediction accuracy of TAGE. Building on top of these proposals, we further show that the Statistical Corrector Predictor can be used to leverage local history to further improve the potential of the TAGE predictor. Furthermore, we show that the use of a Statistical Corrector predictor based on local history, LSC, dwarfs the benefits of the loop predictor and the global history Statistical Corrector.Finally, we present a cost-effective implementation of the TAGE-LSC predictor using single-port memory components and a reduced number of accesses per prediction.},
	urldate = {2024-10-17},
	booktitle = {Proceedings of the 44th {Annual} {IEEE}/{ACM} {International} {Symposium} on {Microarchitecture}},
	publisher = {Association for Computing Machinery},
	author = {Seznec, André},
	month = dec,
	year = {2011},
	pages = {117--127},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/QBLMVHJA/Seznec - 2011 - A new case for the TAGE branch predictor.pdf:application/pdf},
}

@article{seznec64KbytesISLTAGE,
	title = {A 64 {Kbytes} {ISL}-{TAGE} branch predictor},
	language = {en},
	author = {Seznec, André},
	file = {PDF:/Users/ilu/Zotero/storage/DHUG4TYE/Seznec - A 64 Kbytes ISL-TAGE branch predictor.pdf:application/pdf},
}

@inproceedings{seznecStorageFreeConfidence2011,
	title = {Storage free confidence estimation for the {TAGE} branch predictor},
	url = {https://ieeexplore.ieee.org/abstract/document/5749750},
	doi = {10.1109/HPCA.2011.5749750},
	abstract = {For the past 15 years, it has been shown that confidence estimation of branch prediction can be used for various usages such as fetch gating or throttling for power saving or for controlling resource allocation policies in a SMT processor. In many proposals, using extra hardware and particularly storage tables for branch confidence estimators has been considered as a worthwhile silicon investment. The TAGE predictor presented in 2006 is so far considered as the state-of-the-art conditional branch predictor. In this paper, we show that very accurate confidence estimations can be done for the branch predictions performed by the TAGE predictor by simply observing the outputs of the predictor tables. Many confidence estimators proposed in the literature only discriminate between high confidence predictions and low confidence predictions. It has been recently pointed out that a more selective confidence discrimination could useful. We show that the observation of the outputs of the predictor tables is sufficient to grade the confidence in the branch predictions with a very good granularity. Moreover a slight modification of the predictor automaton allows to discriminate the prediction in three classes, low-confidence (with a misprediction rate in the 30 \% range), medium confidence (with a misprediction rate in 8-12\% range) and high confidence (with a misprediction rate lower than 1 \%).},
	urldate = {2024-10-18},
	booktitle = {2011 {IEEE} 17th {International} {Symposium} on {High} {Performance} {Computer} {Architecture}},
	author = {Seznec, André},
	month = feb,
	year = {2011},
	note = {ISSN: 2378-203X},
	keywords = {Accuracy, Automata, Benchmark testing, Estimation, History, Measurement, Radiation detectors},
	pages = {443--454},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/ICJVZCEJ/Seznec - 2011 - Storage free confidence estimation for the TAGE branch predictor.pdf:application/pdf},
}

@inproceedings{seznecTAGESCBranchPredictorsAgain2016,
	title = {{TAGE}-{SC}-{L} {Branch} {Predictors} {Again}},
	url = {https://inria.hal.science/hal-01354253},
	abstract = {Outline In this study, we explore the performance limits of these TAGE-SC-L predictors for respectively 8Kbytes and 64Kbytes of storage budget. For a 8KB storage budget, our submitted predictor used most of its storage budget on the TAGE predictor, features a very small loop predictor LP and a neural statistical cor-rector exploiting global history path and very limited local history. The submitted 8Kbytes predictor achieves 4.991 MPKI on the CBP-5 train traces. With a larger storage budget, one can invest more significant storage budget in the adjunct predictors. The submitted 512Kbits TAGE-SC-L predictor features a TAGE predictor, a loop predictor LP and a quite complex (57 Kbits) neural statistical corrector that exploits various form of local histories , global branch history, IMLI counter [12]. The submitted 64KB TAGE-SC-L predictor achieves 3.986 MPKI on the CBP-5 train traces.},
	language = {en},
	urldate = {2024-10-18},
	author = {Seznec, André},
	year = {2016},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/LWGWKNV5/Seznec - 2016 - TAGE-SC-L Branch Predictors Again.pdf:application/pdf},
}

@inproceedings{seznecTAGESCBranchPredictors2014,
	title = {{TAGE}-{SC}-{L} {Branch} {Predictors}},
	url = {https://inria.hal.science/hal-01086920},
	abstract = {Outline The TAGE predictor [12] is considered as one of the most storage effective global branch/path history predictors. It has been shown that associated with small adjunct predic-tors like a statistical corrector (SC for short) and/or a loop predictor (L for short) [11, 10], TAGE can even be more ef-fective. In this study, we explore the performance limits of these TAGE-SC-L predictors for respectively 32Kbits stor-age budget, 256 Kbits storage budget and quasi-unlimited ({\textless} 2 Gbits) storage budget. With a 32Kbits storage budget, only a very limited stor-age budget can be invested in the adjunct predictors. Then our submitted predictor used most of its storage budget on the TAGE predictor and features only a small loop predictor LP and a simple corrector filter CF. The submitted 32Kbits predictor achieves 3.315 MPKI on the CBP-4 traces. With a larger storage budget, one can invest more signifi-cant storage budget in the adjunct predictors. The submitted 256Kbits TAGE-SC-L predictor features a TAGE predictor, a loop predictor LP and a quite complex (≈ 45 Kbits) statis-tical corrector SC that exploits local history, global branch history and return-associated branch history. The 256Kbits TAGE-SC-L predictor achieves 2.365 MPKI on the CBP-4 traces. The no-limit budget allows to use a statistical corrector build with many components exploiting global branch and path histories, local histories and some form of skeleton his-tories. The submitted predictor achieves 1.782 MPKI on the CBP-4 traces.},
	language = {en},
	urldate = {2024-10-18},
	author = {Seznec, André},
	month = jun,
	year = {2014},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/YWKHE8MC/Seznec - 2014 - TAGE-SC-L Branch Predictors.pdf:application/pdf},
}

@inproceedings{matsuiEfficientImplementationTAGE2019,
	title = {An {Efficient} {Implementation} of a {TAGE} {Branch} {Predictor} for {Soft} {Processors} on {FPGA}},
	url = {https://ieeexplore.ieee.org/abstract/document/8906770},
	doi = {10.1109/MCSoC.2019.00023},
	abstract = {Soft processors are becoming a common component on reconfigurable computing like FPGA. For some accelerators, custom logic functions are implemented as processing elements besides the soft processor. Since the resources in FPGA are fixed and limited, it is desired to implement the soft processor with less logical resources as possible. One of the important parts of the processor is an instruction fetch unit whose performance is dependent on branch prediction. Conventional branch predictors like bimodal or gshare are simple to implement but their prediction accuracy is not good enough. On the other hand, TAGE branch predictor has better prediction accuracy but contains complex logic path for branch prediction, which results in the lower operating frequency. In this paper, we propose a branch predictor called pTAGE, which has almost the same prediction accuracy as TAGE and avoids becoming the critical path of the processor. The branch prediction of pTAGE is pipelined, so prediction result is available on each clock cycle. We implement gshare, TAGE, and pTAGE, respectively in Verilog HDL and evaluate their operating frequency and prediction rate based on FPGA implementation. In this result, pTAGE has almost the same prediction rate as TAGE and 1.41 times higher operating frequency than that of TAGE. Also, we evaluate the performance by varying the latency for updating branch prediction, and the evaluation result shows that pTAGE exhibits higher performance in deep pipelined processors than gshare.},
	urldate = {2024-10-18},
	booktitle = {2019 {IEEE} 13th {International} {Symposium} on {Embedded} {Multicore}/{Many}-core {Systems}-on-{Chip} ({MCSoC})},
	author = {Matsui, Katsunoshin and Ashraful Islam, Md and Kise, Kenji},
	month = oct,
	year = {2019},
	keywords = {branch prediction, Clocks, Field programmable gate arrays, FPGA, Pipeline processing, Program processors, Random access memory, Registers, soft processor, TAGE, Wires},
	pages = {108--115},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/2A5BSP9W/Matsui et al. - 2019 - An Efficient Implementation of a TAGE Branch Predictor for Soft Processors on FPGA.pdf:application/pdf},
}

@article{dangBATAGEBFNPHighPerformanceHybrid2023,
	title = {{BATAGE}-{BFNP}: {A} {High}-{Performance} {Hybrid} {Branch} {Predictor} with {Data}-{Dependent} {Branches} {Speculative} {Pre}-execution for {RISC}-{V} {Processors}},
	volume = {48},
	issn = {2191-4281},
	shorttitle = {{BATAGE}-{BFNP}},
	url = {https://doi.org/10.1007/s13369-022-07593-9},
	doi = {10.1007/s13369-022-07593-9},
	abstract = {Handling control dependence in a pipeline CPU has always been a big problem in computer architecture design. Since the result of a branch instruction becomes available in the execution stage, and the program counter always requires the instruction address after each cycle, it is necessary to predict the address with the available information instead of stalling the pipeline. In this work, we propose BATAGE-BFNP—a hybrid branch predictor that combines two of the most high-performance branch predictors in the literature (Bayesian tagged geometric length and bias-free neural predictor). Our design uses a speculative pre-execution mechanism to predict the outcome of some particular data-dependent branches. Our implementation reduces Misprediction-per-kilo-instructions (MPKI) by 55.5\% compared to BATAGE predictors and 68.2\% compared to bias-free neural predictor in Embench benchmarks.},
	language = {en},
	number = {8},
	urldate = {2024-10-18},
	journal = {Arab J Sci Eng},
	author = {Dang, Nhat Minh and Cao, Hai Xuan and Tran, Linh},
	month = aug,
	year = {2023},
	keywords = {Branch predictor, Data-dependent branch, Neural predictor, RISC-V, Speculative pre-execution, TAGE predictor},
	pages = {10299--10312},
}

@misc{BranchPredictionRISCVBOOMa,
	title = {Branch {Prediction} — {RISCV}-{BOOM} documentation},
	url = {https://docs.boom-core.org/en/latest/sections/branch-prediction/},
	urldate = {2024-10-18},
}

@inproceedings{matsuiEfficientImplementationTAGE2019a,
	title = {An {Efficient} {Implementation} of a {TAGE} {Branch} {Predictor} for {Soft} {Processors} on {FPGA}},
	url = {https://ieeexplore.ieee.org/abstract/document/8906770},
	doi = {10.1109/MCSoC.2019.00023},
	abstract = {Soft processors are becoming a common component on reconfigurable computing like FPGA. For some accelerators, custom logic functions are implemented as processing elements besides the soft processor. Since the resources in FPGA are fixed and limited, it is desired to implement the soft processor with less logical resources as possible. One of the important parts of the processor is an instruction fetch unit whose performance is dependent on branch prediction. Conventional branch predictors like bimodal or gshare are simple to implement but their prediction accuracy is not good enough. On the other hand, TAGE branch predictor has better prediction accuracy but contains complex logic path for branch prediction, which results in the lower operating frequency. In this paper, we propose a branch predictor called pTAGE, which has almost the same prediction accuracy as TAGE and avoids becoming the critical path of the processor. The branch prediction of pTAGE is pipelined, so prediction result is available on each clock cycle. We implement gshare, TAGE, and pTAGE, respectively in Verilog HDL and evaluate their operating frequency and prediction rate based on FPGA implementation. In this result, pTAGE has almost the same prediction rate as TAGE and 1.41 times higher operating frequency than that of TAGE. Also, we evaluate the performance by varying the latency for updating branch prediction, and the evaluation result shows that pTAGE exhibits higher performance in deep pipelined processors than gshare.},
	urldate = {2024-10-18},
	booktitle = {2019 {IEEE} 13th {International} {Symposium} on {Embedded} {Multicore}/{Many}-core {Systems}-on-{Chip} ({MCSoC})},
	author = {Matsui, Katsunoshin and Ashraful Islam, Md and Kise, Kenji},
	month = oct,
	year = {2019},
	keywords = {branch prediction, Clocks, Field programmable gate arrays, FPGA, Pipeline processing, Program processors, Random access memory, Registers, soft processor, TAGE, Wires},
	pages = {108--115},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/Q6383KYK/Matsui et al. - 2019 - An Efficient Implementation of a TAGE Branch Predictor for Soft Processors on FPGA.pdf:application/pdf},
}

@inproceedings{jimenezDynamicBranchPrediction2001,
	title = {Dynamic branch prediction with perceptrons},
	url = {https://ieeexplore.ieee.org/abstract/document/903263},
	doi = {10.1109/HPCA.2001.903263},
	abstract = {This paper presents a new method for branch prediction. The key idea is to use one of the simplest possible neural networks, the perceptron, as an alternative to the commonly used two-bit counters. Our predictor achieves increased accuracy by making use of long branch histories, which are possible becasue the hardware resources for our method scale linearly with the history length. By contrast, other purely dynamic schemes require exponential resources. We describe our design and evaluate it with respect to two well known predictors. We show that for a 4K byte hardware budget our method improves misprediction rates for the SPEC 2000 benchmarks by 10.1\% over the gshare predictor. Our experiments also provide a better understanding of the situations in which traditional predictors do and do not perform well. Finally, we describe techniques that allow our complex predictor to operate in one cycle.},
	urldate = {2024-10-18},
	booktitle = {Proceedings {HPCA} {Seventh} {International} {Symposium} on {High}-{Performance} {Computer} {Architecture}},
	author = {Jimenez, D.A. and Lin, C.},
	month = jan,
	year = {2001},
	note = {ISSN: 1530-0897},
	keywords = {Accuracy, Computer architecture, Counting circuits, Hardware, History, Modems, Neural networks, Parallel processing, Prefetching, Space exploration},
	pages = {197--206},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/ZDYB5AMX/Jimenez and Lin - 2001 - Dynamic branch prediction with perceptrons.pdf:application/pdf},
}

@article{tarjanMergingPathGshare2005,
	title = {Merging path and gshare indexing in perceptron branch prediction},
	volume = {2},
	issn = {1544-3566},
	url = {https://dl.acm.org/doi/10.1145/1089008.1089011},
	doi = {10.1145/1089008.1089011},
	abstract = {We introduce the hashed perceptron predictor, which merges the concepts behind the gshare, path-based and perceptron branch predictors. This predictor can achieve superior accuracy to a path-based and a global perceptron predictor, previously the most accurate dynamic branch predictors known in the literature. We also show how such a predictor can be ahead pipelined to yield one cycle effective latency. On the SPECint2000 set of benchmarks, the hashed perceptron predictor improves accuracy by up to 15.6\% over a MAC-RHSP and 27.2\% over a path-based neural predictor.},
	number = {3},
	urldate = {2024-10-18},
	journal = {ACM Trans. Archit. Code Optim.},
	author = {Tarjan, David and Skadron, Kevin},
	month = sep,
	year = {2005},
	pages = {280--300},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/82FUWHE2/Tarjan and Skadron - 2005 - Merging path and gshare indexing in perceptron branch prediction.pdf:application/pdf},
}

@inproceedings{garzaBitlevelPerceptronPrediction2019,
	address = {New York, NY, USA},
	series = {{ISCA} '19},
	title = {Bit-level perceptron prediction for indirect branches},
	isbn = {978-1-4503-6669-4},
	url = {https://dl.acm.org/doi/10.1145/3307650.3322217},
	doi = {10.1145/3307650.3322217},
	abstract = {Modern software uses indirect branches for various purposes including, but not limited to, virtual method dispatch and implementation of switch statements. Because an indirect branch's target address cannot be determined prior to execution, high-performance processors depend on highly-accurate indirect branch prediction techniques to mitigate control hazards.This paper proposes a new indirect branch prediction scheme that predicts target addresses at the bit level. Using a series of perceptron-based predictors, our predictor predicts individual branch target address bits based on correlations within branch history. Our evaluations show this new branch target predictor is competitive with state-of-the-art branch target predictors at an equivalent hardware budget. For instance, over a set of workloads including SPEC and mobile applications, our predictor achieves a misprediction rate of 0.183 mispredictions per 1000 instructions, compared with 0.193 for the state-of-the-art ITTAGE predictor and 0.29 for a VPC-based indirect predictor.},
	urldate = {2024-10-17},
	booktitle = {Proceedings of the 46th {International} {Symposium} on {Computer} {Architecture}},
	publisher = {Association for Computing Machinery},
	author = {Garza, Elba and Mirbagher-Ajorpaz, Samira and Khan, Tahsin Ahmad and Jiménez, Daniel A.},
	month = jun,
	year = {2019},
	pages = {27--38},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/CXFTRMW6/Garza et al. - 2019 - Bit-level perceptron prediction for indirect branches.pdf:application/pdf},
}

@article{jimenezNeuralMethodsDynamic2002,
	title = {Neural methods for dynamic branch prediction},
	volume = {20},
	issn = {0734-2071},
	url = {https://dl.acm.org/doi/10.1145/571637.571639},
	doi = {10.1145/571637.571639},
	abstract = {This article presents a new and highly accurate method for branch prediction. The key idea is to use one of the simplest possible neural methods, the perceptron, as an alternative to the commonly used two-bit counters. The source of our predictor's accuracy is its ability to use long history lengths, because the hardware resources for our method scale linearly, rather than exponentially, with the history length. We describe two versions of perceptron predictors, and we evaluate these predictors with respect to five well-known predictors. We show that for a 4 KB hardware budget, a simple version of our method that uses a global history achieves a misprediction rate of 4.6\% on the SPEC 2000 integer benchmarks, an improvement of 26\% over gshare. We also introduce a global/local version of our predictor that is 14\% more accurate than the McFarling-style hybrid predictor of the Alpha 21264. We show that for hardware budgets of up to 256 KB, this global/local perceptron predictor is more accurate than Evers' multicomponent predictor, so we conclude that ours is the most accurate dynamic predictor currently available. To explore the feasibility of our ideas, we provide a circuit-level design of the perceptron predictor and describe techniques that allow our complex predictor to operate quickly. Finally, we show how the relatively complex perceptron predictor can be used in modern CPUs by having it override a simpler, quicker Smith predictor, providing IPC improvements of 15.8\% over gshare and 5.7\% over the McFarling hybrid predictor.},
	number = {4},
	urldate = {2024-10-18},
	journal = {ACM Trans. Comput. Syst.},
	author = {Jiménez, Daniel A. and Lin, Calvin},
	month = nov,
	year = {2002},
	pages = {369--397},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/7DRLKVYR/Jiménez and Lin - 2002 - Neural methods for dynamic branch prediction.pdf:application/pdf},
}

@article{kothaComparativeStudyBranch,
	title = {A {Comparative} {Study} of {Branch} {Predictors}},
	language = {en},
	author = {Kotha, Aparna},
	file = {PDF:/Users/ilu/Zotero/storage/L9SBN26X/Kotha - A Comparative Study of Branch Predictors.pdf:application/pdf},
}

@misc{mittalSurveyTechniquesDynamic2018,
	title = {A {Survey} of {Techniques} for {Dynamic} {Branch} {Prediction}},
	url = {http://arxiv.org/abs/1804.00261},
	doi = {10.48550/arXiv.1804.00261},
	abstract = {Branch predictor (BP) is an essential component in modern processors since high BP accuracy can improve performance and reduce energy by decreasing the number of instructions executed on wrong-path. However, reducing latency and storage overhead of BP while maintaining high accuracy presents significant challenges. In this paper, we present a survey of dynamic branch prediction techniques. We classify the works based on key features to underscore their differences and similarities. We believe this paper will spark further research in this area and will be useful for computer architects, processor designers and researchers.},
	urldate = {2024-10-18},
	publisher = {arXiv},
	author = {Mittal, Sparsh},
	month = apr,
	year = {2018},
	note = {arXiv:1804.00261},
	keywords = {Computer Science - Hardware Architecture},
	file = {Preprint PDF:/Users/ilu/Zotero/storage/FILMJYC3/Mittal - 2018 - A Survey of Techniques for Dynamic Branch Prediction.pdf:application/pdf;Snapshot:/Users/ilu/Zotero/storage/WWJN8YAF/1804.html:text/html},
}

@inproceedings{butkoDesignExplorationNext2015,
	title = {Design {Exploration} for next {Generation} {High}-{Performance} {Manycore} {On}-chip {Systems}: {Application} to big.{LITTLE} {Architectures}},
	shorttitle = {Design {Exploration} for next {Generation} {High}-{Performance} {Manycore} {On}-chip {Systems}},
	url = {https://ieeexplore.ieee.org/document/7309629/?arnumber=7309629},
	doi = {10.1109/ISVLSI.2015.28},
	abstract = {Next generation embedded systems will massively adopt on-chip many core architectures to provide both performance and energy-efficiency. This trend will definitely establish the convergence of embedded computing and high-performance computing. In such a context, one major design challenge will concern the choice of adequate architecture parameters given system requirements. Moreover, it will affect the way applications can suitably exploit architecture resources for an efficient execution. This paper deals with many core on-chip system design exploration by using via simulation. It presents an approach enabling one to study central design parameters in an accurate and cost-effective manner. This approach is illustrated through the design exploration for ARM big. LITTLE heterogeneous multicore technology in the gem5 framework.},
	urldate = {2024-10-18},
	booktitle = {2015 {IEEE} {Computer} {Society} {Annual} {Symposium} on {VLSI}},
	author = {Butko, Anastasiia and Gamatié, Abdoulaye and Sassatelli, Gilles and Torres, Lionel and Robert, Michel},
	month = jul,
	year = {2015},
	note = {ISSN: 2159-3477},
	keywords = {Accuracy, Benchmark testing, big.LITTLE, Computational modeling, energy-efficiency, gem5, heterogeneous, High-performance computing, Kernel, manycore, modeling, Multicore processing, System-on-chip, trace-driven},
	pages = {551--556},
	file = {Full Text PDF:/Users/ilu/Zotero/storage/FGKQYZPI/Butko et al. - 2015 - Design Exploration for next Generation High-Performance Manycore On-chip Systems Application to big.pdf:application/pdf;IEEE Xplore Abstract Record:/Users/ilu/Zotero/storage/PMBSFBEW/7309629.html:text/html},
}

@misc{lowepower2020gem5simulatorversion200,
      title={The gem5 Simulator: Version 20.0+}, 
      author={Jason Lowe-Power and Abdul Mutaal Ahmad and Ayaz Akram and Mohammad Alian and Rico Amslinger and Matteo Andreozzi and Adrià Armejach and Nils Asmussen and Brad Beckmann and Srikant Bharadwaj and Gabe Black and Gedare Bloom and Bobby R. Bruce and Daniel Rodrigues Carvalho and Jeronimo Castrillon and Lizhong Chen and Nicolas Derumigny and Stephan Diestelhorst and Wendy Elsasser and Carlos Escuin and Marjan Fariborz and Amin Farmahini-Farahani and Pouya Fotouhi and Ryan Gambord and Jayneel Gandhi and Dibakar Gope and Thomas Grass and Anthony Gutierrez and Bagus Hanindhito and Andreas Hansson and Swapnil Haria and Austin Harris and Timothy Hayes and Adrian Herrera and Matthew Horsnell and Syed Ali Raza Jafri and Radhika Jagtap and Hanhwi Jang and Reiley Jeyapaul and Timothy M. Jones and Matthias Jung and Subash Kannoth and Hamidreza Khaleghzadeh and Yuetsu Kodama and Tushar Krishna and Tommaso Marinelli and Christian Menard and Andrea Mondelli and Miquel Moreto and Tiago Mück and Omar Naji and Krishnendra Nathella and Hoa Nguyen and Nikos Nikoleris and Lena E. Olson and Marc Orr and Binh Pham and Pablo Prieto and Trivikram Reddy and Alec Roelke and Mahyar Samani and Andreas Sandberg and Javier Setoain and Boris Shingarov and Matthew D. Sinclair and Tuan Ta and Rahul Thakur and Giacomo Travaglini and Michael Upton and Nilay Vaish and Ilias Vougioukas and William Wang and Zhengrong Wang and Norbert Wehn and Christian Weis and David A. Wood and Hongil Yoon and Éder F. Zulian},
      year={2020},
      eprint={2007.03152},
      archivePrefix={arXiv},
      primaryClass={cs.AR},
      url={https://arxiv.org/abs/2007.03152}, 
}
